Dưới đây là một số đoạn code mẹo và câu hỏi đánh đố cho việc phỏng vấn ứng viên chuyên gia backend PHP. Những câu hỏi này nhằm kiểm tra sự hiểu biết sâu rộng về PHP, các vấn đề về hiệu suất, và khả năng tư duy logic.

### 1. **Câu hỏi: Xử lý lỗi trong đoạn code sau**

**Đoạn mã:**

```php
function testFunction($a, $b) {
    return $a / $b;
}

echo testFunction(10, 0);
```

**Câu hỏi: Có gì sai với đoạn mã trên và bạn sẽ sửa lỗi như thế nào?**

**Trả lời:**

Đoạn mã trên sẽ gây lỗi chia cho số 0. PHP sẽ sinh ra một cảnh báo "Division by zero". Để xử lý lỗi, bạn nên kiểm tra xem biến `$b` có phải là 0 trước khi thực hiện phép chia.

**Sửa lỗi:**

```php
function testFunction($a, $b) {
    if ($b == 0) {
        throw new Exception('Cannot divide by zero.');
    }
    return $a / $b;
}

try {
    echo testFunction(10, 0);
} catch (Exception $e) {
    echo 'Error: ' . $e->getMessage();
}
```

### 2. **Câu hỏi: Xử lý vấn đề về tham chiếu trong PHP**

**Đoạn mã:**

```php
$a = [1, 2, 3];
$b = $a;
$b[] = 4;

print_r($a);
print_r($b);
```

**Câu hỏi: Đoạn mã trên sẽ in ra kết quả gì và tại sao?**

**Trả lời:**

Đoạn mã trên sẽ in ra:

```
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
)
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
)
```

Giải thích: Mặc dù `$b` là một bản sao của `$a`, nhưng khi bạn thêm phần tử vào `$b`, nó không ảnh hưởng đến `$a` vì PHP sao chép giá trị của mảng. Mảng `$b` là một bản sao độc lập của `$a` tại thời điểm sao chép.

### 3. **Câu hỏi: Hiểu về vấn đề `null` và `isset`**

**Đoạn mã:**

```php
$var = null;

if (isset($var)) {
    echo "Variable is set";
} else {
    echo "Variable is not set";
}
```

**Câu hỏi: Đoạn mã trên sẽ in ra gì và tại sao?**

**Trả lời:**

Đoạn mã trên sẽ in ra "Variable is set". Trong PHP, `isset()` trả về `false` chỉ khi biến không được khai báo hoặc có giá trị `null`. Trong trường hợp này, biến `$var` được khai báo và có giá trị `null`, vì vậy `isset($var)` trả về `true`.

### 4. **Câu hỏi: Hiểu về sự khác biệt giữa `==` và `===`**

**Đoạn mã:**

```php
$a = 0;
$b = '0';

if ($a == $b) {
    echo "Equal with ==\n";
}

if ($a === $b) {
    echo "Equal with ===\n";
}
```

**Câu hỏi: Đoạn mã trên sẽ in ra gì và tại sao?**

**Trả lời:**

Đoạn mã trên sẽ in ra:

```
Equal with ==
```

Không in ra dòng thông báo của `===`.

Giải thích: `==` so sánh giá trị và thực hiện kiểu dữ liệu tự động, do đó `$a == $b` là `true`. Tuy nhiên, `===` so sánh cả giá trị và kiểu dữ liệu, và vì `$a` (số nguyên) khác với `$b` (chuỗi), nên `$a === $b` là `false`.

### 5. **Câu hỏi: Hiểu về `clone` và `copy` trong PHP**

**Đoạn mã:**

```php
class MyClass {
    public $value;

    public function __construct($value) {
        $this->value = $value;
    }
}

$obj1 = new MyClass(10);
$obj2 = clone $obj1;
$obj2->value = 20;

echo $obj1->value;
echo $obj2->value;
```

**Câu hỏi: Đoạn mã trên sẽ in ra kết quả gì và tại sao?**

**Trả lời:**

Đoạn mã trên sẽ in ra:

```
10
20
```

Giải thích: `clone` tạo ra một bản sao nông của đối tượng, nghĩa là một bản sao của đối tượng với các thuộc tính tương tự, nhưng không sao chép các đối tượng tham chiếu bên trong. Do đó, thay đổi thuộc tính của `$obj2` không ảnh hưởng đến `$obj1`.

### 6. **Câu hỏi: Tìm hiểu về `call_user_func` và `call_user_func_array`**

**Đoạn mã:**

```php
function test($a, $b) {
    return $a + $b;
}

echo call_user_func('test', 1, 2);
echo call_user_func_array('test', [1, 2]);
```

**Câu hỏi: Đoạn mã trên sẽ in ra gì và giải thích?**

**Trả lời:**

Đoạn mã trên sẽ in ra:

```
34
```

Giải thích: `call_user_func` và `call_user_func_array` đều gọi hàm với các tham số truyền vào. `call_user_func` nhận từng tham số riêng biệt, trong khi `call_user_func_array` nhận một mảng các tham số. Kết quả sẽ giống nhau nếu tham số là một mảng.

### 7. **Câu hỏi: Hiểu về `__get` và `__set`**

**Đoạn mã:**

```php
class MyClass {
    private $data = [];

    public function __get($name) {
        return $this->data[$name] ?? null;
    }

    public function __set($name, $value) {
        $this->data[$name] = $value;
    }
}

$obj = new MyClass();
$obj->key = 'value';
echo $obj->key;
```

**Câu hỏi: Đoạn mã trên sẽ in ra gì và giải thích?**

**Trả lời:**

Đoạn mã trên sẽ in ra `value`.

Giải thích: Phương thức `__set` được gọi khi một thuộc tính không thể truy cập được (như thuộc tính private) và phương thức `__get` được gọi khi thuộc tính không tồn tại hoặc không thể truy cập được. Trong trường hợp này, `__set` lưu giá trị vào mảng `$data` và `__get` trả về giá trị từ mảng `$data`.

### 8. **Câu hỏi: Hiểu về tính kế thừa và override**

**Đoạn mã:**

```php
class ParentClass {
    public function show() {
        echo "ParentClass";
    }
}

class ChildClass extends ParentClass {
    public function show() {
        echo "ChildClass";
    }
}

$obj = new ChildClass();
$obj->show();
```

**Câu hỏi: Đoạn mã trên sẽ in ra gì và tại sao?**

**Trả lời:**

Đoạn mã trên sẽ in ra `ChildClass`.

Giải thích: Phương thức `show` trong lớp `ChildClass` ghi đè phương thức cùng tên trong lớp `ParentClass`. Do đó, khi gọi phương thức `show` từ đối tượng của `ChildClass`, phương thức của lớp con sẽ được thực thi.

Các câu hỏi này sẽ giúp bạn đánh giá sự hiểu biết của ứng viên về các khái niệm cơ bản và nâng cao trong PHP, cũng như khả năng giải quyết vấn đề và tư duy logic. Nếu bạn cần thêm các câu hỏi khác hoặc có yêu cầu cụ thể hơn, hãy cho tôi biết!
