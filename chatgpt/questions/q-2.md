Dưới đây là danh sách các câu hỏi phỏng vấn cho lập trình viên PHP cao cấp (backend) cùng với câu trả lời chi tiết. Những câu hỏi này bao gồm các khía cạnh từ kiến thức cơ bản đến các vấn đề phức tạp hơn liên quan đến PHP và phát triển backend.

### 1. Câu hỏi: Bạn giải thích thế nào về các mức độ phạm vi biến (variable scope) trong PHP?
**Trả lời:**
- **Local Scope:** Các biến khai báo trong một hàm chỉ có thể được truy cập trong phạm vi của hàm đó. Ví dụ:
  ```php
  function test() {
      $localVar = "I'm local";
      echo $localVar; // Có thể truy cập
  }
  test();
  echo $localVar; // Lỗi: Biến không xác định
  ```
- **Global Scope:** Các biến khai báo ngoài mọi hàm có thể được truy cập từ bên ngoài hàm. Để sử dụng biến toàn cục trong hàm, bạn cần khai báo nó với từ khóa `global`.
  ```php
  $globalVar = "I'm global";

  function test() {
      global $globalVar;
      echo $globalVar; // Có thể truy cập
  }
  test();
  ```
- **Static Scope:** Biến khai báo với từ khóa `static` trong hàm giữ giá trị của nó giữa các lần gọi hàm. Điều này khác với biến local, vì nó không bị xóa sau khi hàm kết thúc.
  ```php
  function test() {
      static $counter = 0;
      $counter++;
      echo $counter;
  }
  test(); // 1
  test(); // 2
  ```
- **Global Variables and Superglobals:** Các biến superglobal như `$_POST`, `$_GET`, `$_SESSION` là toàn cục và có thể được truy cập từ bất kỳ đâu trong script.

### 2. Câu hỏi: Bạn giải thích sự khác biệt giữa `include`, `require`, `include_once`, và `require_once` trong PHP?
**Trả lời:**
- **`include`**: Thực hiện việc bao gồm và thực thi file được chỉ định. Nếu file không tồn tại, PHP sẽ cảnh báo nhưng vẫn tiếp tục thực thi.
  ```php
  include 'file.php';
  ```
- **`require`**: Tương tự như `include`, nhưng nếu file không tồn tại, PHP sẽ gây ra lỗi nghiêm trọng và dừng thực thi.
  ```php
  require 'file.php';
  ```
- **`include_once`**: Giống như `include`, nhưng sẽ đảm bảo rằng file được bao gồm chỉ một lần. Nếu file đã được bao gồm trước đó, nó sẽ không bao gồm lại.
  ```php
  include_once 'file.php';
  ```
- **`require_once`**: Giống như `require`, nhưng cũng đảm bảo rằng file được bao gồm chỉ một lần. Nếu file đã được bao gồm trước đó, nó sẽ không bao gồm lại.
  ```php
  require_once 'file.php';
  ```

### 3. Câu hỏi: Giải thích các phương thức CRUD trong PHP và cách bạn có thể thực hiện chúng sử dụng PDO.
**Trả lời:**
- **Create (Tạo):** Thêm dữ liệu mới vào cơ sở dữ liệu.
  ```php
  $stmt = $pdo->prepare("INSERT INTO users (name, email) VALUES (:name, :email)");
  $stmt->execute(['name' => $name, 'email' => $email]);
  ```
- **Read (Đọc):** Lấy dữ liệu từ cơ sở dữ liệu.
  ```php
  $stmt = $pdo->prepare("SELECT * FROM users WHERE id = :id");
  $stmt->execute(['id' => $id]);
  $user = $stmt->fetch();
  ```
- **Update (Cập nhật):** Cập nhật dữ liệu hiện có.
  ```php
  $stmt = $pdo->prepare("UPDATE users SET email = :email WHERE id = :id");
  $stmt->execute(['email' => $newEmail, 'id' => $id]);
  ```
- **Delete (Xóa):** Xóa dữ liệu khỏi cơ sở dữ liệu.
  ```php
  $stmt = $pdo->prepare("DELETE FROM users WHERE id = :id");
  $stmt->execute(['id' => $id]);
  ```

### 4. Câu hỏi: Bạn có thể giải thích về Dependency Injection (DI) trong PHP không? Tại sao nó quan trọng?
**Trả lời:**
Dependency Injection (DI) là một kỹ thuật thiết kế trong lập trình hướng đối tượng, giúp tách biệt các thành phần trong ứng dụng và giảm sự phụ thuộc giữa chúng. DI cung cấp các phụ thuộc của một đối tượng từ bên ngoài thay vì tạo chúng bên trong đối tượng đó. Có ba kiểu DI phổ biến:
- **Constructor Injection:** Truyền các phụ thuộc thông qua constructor.
- **Setter Injection:** Truyền các phụ thuộc thông qua các phương thức setter.
- **Interface Injection:** Đối tượng phụ thuộc cung cấp phụ thuộc thông qua một phương thức interface.

**Tầm quan trọng:**
- **Tách biệt phụ thuộc:** Giúp dễ dàng thay đổi và kiểm soát các phụ thuộc của một lớp.
- **Dễ dàng kiểm thử:** Cho phép mock hoặc stub các phụ thuộc trong quá trình kiểm thử.
- **Quản lý mã nguồn:** Giúp mã nguồn dễ hiểu và bảo trì hơn.

### 5. Câu hỏi: Giải thích về các kỹ thuật caching trong PHP và khi nào bạn nên sử dụng chúng.
**Trả lời:**
Caching giúp cải thiện hiệu suất ứng dụng bằng cách lưu trữ dữ liệu tạm thời để tránh việc truy xuất lại dữ liệu từ nguồn gốc mỗi khi có yêu cầu. Một số kỹ thuật caching phổ biến:
- **APCu:** Cache dữ liệu trong bộ nhớ. Thích hợp cho các ứng dụng PHP đơn giản và không phân tán.
  ```php
  apcu_store('key', 'value');
  $value = apcu_fetch('key');
  ```
- **Memcached:** Cache phân tán cho phép lưu trữ dữ liệu trên nhiều máy chủ.
  ```php
  $memcached = new Memcached();
  $memcached->addServer('localhost', 11211);
  $memcached->set('key', 'value');
  $value = $memcached->get('key');
  ```
- **Redis:** Một hệ thống lưu trữ dữ liệu key-value phân tán với các tính năng mở rộng.
  ```php
  $redis = new Redis();
  $redis->connect('localhost', 6379);
  $redis->set('key', 'value');
  $value = $redis->get('key');
  ```

**Khi nào sử dụng:**
- **Tăng tốc độ truy cập dữ liệu:** Khi dữ liệu không thay đổi thường xuyên nhưng yêu cầu truy cập thường xuyên.
- **Giảm tải cho cơ sở dữ liệu:** Khi bạn có nhiều yêu cầu đọc dữ liệu từ cơ sở dữ liệu.
- **Cải thiện hiệu suất ứng dụng:** Đặc biệt là với các ứng dụng web có lượng truy cập cao.

### 6. Câu hỏi: Bạn có thể giải thích về các cơ chế bảo mật trong PHP như SQL Injection, XSS, và CSRF không?
**Trả lời:**
- **SQL Injection:** Một lỗ hổng bảo mật cho phép kẻ tấn công chèn hoặc thao tác câu lệnh SQL. Để bảo vệ:
  - Sử dụng Prepared Statements với PDO hoặc MySQLi.
  - Tránh sử dụng các truy vấn SQL trực tiếp với các tham số không được kiểm tra.

- **XSS (Cross-Site Scripting):** Một lỗ hổng bảo mật cho phép kẻ tấn công chèn mã JavaScript độc hại vào trang web. Để bảo vệ:
  - Escape tất cả dữ liệu đầu vào trước khi hiển thị trên trang web.
  - Sử dụng các hàm như `htmlspecialchars()` hoặc `htmlentities()` để bảo vệ.

- **CSRF (Cross-Site Request Forgery):** Một loại tấn công mà kẻ tấn công giả mạo yêu cầu từ một người dùng đã đăng nhập. Để bảo vệ:
  - Sử dụng token xác thực CSRF trong các form và yêu cầu POST.
  - Kiểm tra token trên server trước khi xử lý yêu cầu.

### 7. Câu hỏi: Giải thích về các pattern thiết kế phổ biến trong PHP, như Singleton, Factory, và MVC.
**Trả lời:**
- **Singleton Pattern:** Đảm bảo rằng chỉ có một instance của một lớp được tạo ra và cung cấp điểm truy cập toàn cục đến instance đó.
  ```php
  class Singleton {
      private static $instance = null;

      private function __construct() {}

      public static function getInstance() {
          if (self::$instance === null) {
              self::$instance = new Singleton();
          }
          return self::$instance;
      }
  }
  ```
- **Factory Pattern:** Cung cấp một phương thức để tạo đối tượng mà không cần phải xác định lớp cụ thể của đối tượng đó.
  ```php
  class ProductFactory {
      public static function create($type) {
          switch($type) {
              case 'A':
                  return new ProductA();
              case 'B':
                  return new ProductB();
              default:
                  throw new Exception("Unknown product type.");
          }
      }
  }
  ```
- **MVC (Model-View-Controller):** Pattern phân tách ứng dụng thành
