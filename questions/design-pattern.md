# Design Patterns

### Định nghĩa Design Pattern

> **Design Pattern** là một mô hình thiết kế được sử dụng để giải quyết một vấn đề cụ thể trong lập trình. Nó cung cấp một giải pháp đã được kiểm nghiệm và tối ưu hóa, giúp các lập trình viên tiết kiệm thời gian và công sức khi phát triển phần mềm

### Lịch sử ra đời và phát triển

- Design Pattern được khai sinh vào những năm 1970 với sự phát triển của lập trình hướng đối tượng (OOP). Kể từ đó, nó đã trở thành một phần quan trọng trong quá trình phát triển phần mềm.

- Năm 1994, ba lập trình viên Erich Gamma, Richard Helm, Ralph Johnson và John Vlissides đã xuất bản cuốn sách "Design Patterns: Elements Of Resuable Object - Oriented Software". Cuốn sách này đã trở thành một trong những tài liệu tham khảo quan trọng nhất về Design Pattern.

- Trong những năm gần đây, Design Pattern tiếp tục được phát triển và mở rộng. Ngày càng có nhiều Design Pattern mới được giới thiệu, phù hợp với các yêu cầu mới của lâp trình.

### Ý nghĩa và lợi ích của Design Pattern

##### Design Pattern mang lại nhiều ý nghĩa và lợi ích cho lập trình, bao gồm

- Giúp giải quyết vấn đề một cách hiệu quả và tối ưu: Design Pattern cung cấp các giải pháp đã được kiểm nghiệm và tối ưu hóa, giúp các lập trình viên giải quyết các vấn đề một cách nhanh chóng và hiêu quả.

- Tăng tính tái sử dụng của code: Design Pattern giúp các lập trình viên tái sử dụng code đã có, từ đó giảm thiểu thời gian và công ức phát triển phần mềm.

- Tăng tính bảo trì và bảo dưỡng của phần mềm: Design Pattern giúp phần mềm dễ dàng bảo trì và bảo dưỡng hơn.

- Tăng tính dể hiểu và dễ đọc của code: Design Pattern giúp code dễ hiểu và dễ đọc hơn, giúp việc công tác giữa các lập trình viên trở nên dễ dàng hơn.

- Design Pattern là một kỹ thuật nâng cao của OOP, nó cực kì quan trọng trong lập trình. Nó mang lại nhiều ý nghĩa và lợi ích cho lập trình, giúp các lập trình viên phát triển phần mềm hiệu quả hơn.

### Phân loại Design Pattern

- **Creational Design Patterns:** liên quan tới việc khởi tạo đối tượng. Nhóm pattern này cung cấp các cơ chế tạo đối tượng một cách linh hoạt và phù hợp với bối cảnh sử dụng. Một số pattern phổ biến:

  - **Singleton**
  - **Factory Method**
  - **Abstract Factory**
  - **Builder**
  - **Prototype**

Sử dụng Creational Patterns giúp tạo ra các đối tượng một cách linh hoạt, dễ dàng thay đổi và tối ưu hóa bộ nhớ.

- **Structural Design Patterns:** liên quan tới cấu trúc và mối quan hệ giữa các lớp, đối tượng. Nhóm này giúp xây dựng cấu trúc phần mềm dễ thay đổi và bảo trì. Một số pattern:
  - **Adapter**
  - **Bridge**
  - **Composite**
  - **Decorator**
  - **Facade**
  - **Flyweight**
  - **Proxy**

Sử dụng Structural Patterns giúp xây dựng hệ thống linh hoạt, dễ mở rộng và tối ưu hóa bộ nhớ.

- **Behavioral Design Patterns:** liên quan tới hành vi giao tiếp giữa các đối tượng. Nhóm này giúp định nghĩa rõ ràng mối quan hệ giữa các object. Một số pattern:
  - **Chain of Responsibility**
  - **Command**
  - **Iterator**
  - **Mediator**
  - **Memento**
  - **Observer**
  - **State**
  - **Strategy**
  - **Template Method**
  - **Visitor**

Sử dụng Behavioral Patterns giúp tạo hệ thống linh hoạt, dễ thay đổi và tối ưu hóa hiệu suất.

### Sử dụng Design Pattern

**Nguyên Tắc**

Để áp dụng **Design Pattern** hiệu quả, các lập trinh viên cần nắm được các nguyên tắc và phương pháp sau đây:

- Nguyên tắc đầu tiên là phải hiểu rõ vấn đề cần giải quyết: Trước khi áp dụng Design Pattern, các lập trinh viên cần hiểu rõ vấn đề cần giải quyết là gì. Từ đó, họ có thể lựa chọn được Design Pattern phù hợp nhất.

- Nguyên tắc thứ hai là phải hiểu rõ Design Pattern: Các lập trình viên cần hiểu rõ bản chất và cách hoạt động của Design Pattern. Từ đó, họ có thể áp dụng Design Pattern một cách chính xác và hiệu quả.

- Nguyên tắc thứ ba là phải linh hoạt trong việc áp dụng Design Pattern: Không phải lúc nào cũng có thể áp dụng Design Pattern một cách cứng nhắc. Các lập trình viên cần linh hoạt trong việc áp dụng Design Pattern để phù hợp với nhu cầu cụ thể của dự án.

**Phương pháp**

- Phương pháp trực tiếp: Phương pháp này áp dụng Design Pattern một cách trực tiếp, không cần thay đổi cấu trúc của code.

- Phương pháp gián tiếp: Phương pháp này sử dụng các thư viện hoặc framework để áp dụng Design Pattern.

### **Lợi ích của việc sử dụng Design Pattern trong phát triển phần mềm**

- Giúp giải quyết vấn đề một cách hiệu quả và tối ưu: Design Pattern cung cấp các giải pháp đã được kiểm nghiệm và tối ưu hoá, giúp các lập trình viên giải quyết các vấn đề một cách nhanh chóng và hiệu quả hơn.

- Tăng tính tái sử dụng của code: Design Pattern giúp các lập trình viên tái sử dụng code đã có, từ đó giảm thiểu thời gian và công sức phát triển phần mềm.

- Tăng tính linh hoạt và mở rộng của phần mềm: Design Pattern giúp phần mềm linh hoạt và dễ dàng mở rộng khi có nhu cầu thay đổi.

- Tăng tính bảo trì và bảo dưỡng của phần mềm: Design Pattern giúp phền mềm dễ dàng bảo trì và bảo dưỡng hơn.

- Tăng tính dễ hiểu và dễ đọc của code: Design Pattern giúp code dễ hiểu và dễ đọc hơn, giúp việc công tá giữa các lập trình viên trở nên dễ dàng.

### Lưu ý khi áp dụng Design Pattern

Khi áp dụng Design Pattern, các lập trình viên cần lưu ý những điểm sau:

- Không nên áp dụng Design Pattern một cách cứng nhắc: Design Pattern là một giải pháp tổng thể, không phải là một giải pháp hoàn hảo. Các lập trình viên cần linh hoạt trong việc áp dụng Design Pattern để phù hợp với nhu cầu cụ thể của dự án.

- Không nên làm dụng Design Pattern: Design pattern không phải là một giải pháp cho mọi vấn đề. Các lập trình viên chỉ nên áp dụng Design Pattern khi nó thực sự cần thiết.

- Cần có thời gian để học hỏi và nghiên cứu Design Pattern: Design Pattern là một kỹ thuật phức tạp, cần có thời gian để học hỏi và nghiên cứu. Các lập trình viên không nên vội vàng áp dụng Design Pattern mà không hiểu rõ bản chất và cách hoạt động của nó.

### Một số design pattern phổ biến và thường được các lập trình viên áp dụng minh họa bằng PHP

### 1. **Singleton Pattern**

**Mục đích:** Đảm bảo rằng một lớp chỉ có một thể hiện duy nhất và cung cấp một điểm truy cập toàn cục đến thể hiện đó.

**Ví dụ:**

```php
class Singleton {
    private static $instance;

    // Constructor được đặt là private để ngăn tạo mới bên ngoài
    private function __construct() {}

    // Trả về thể hiện duy nhất của lớp
    public static function getInstance() {
        if (self::$instance === null) {
            self::$instance = new Singleton();
        }
        return self::$instance;
    }

    public function doSomething() {
        echo "Doing something!";
    }
}

// Sử dụng Singleton
$instance = Singleton::getInstance();
$instance->doSomething();
```

### 2. **Factory Pattern**

**Mục đích:** Cung cấp một giao diện để tạo ra đối tượng mà không cần chỉ định lớp cụ thể của đối tượng đó.

**Ví dụ:**

```php
interface Shape {
    public function draw();
}

class Circle implements Shape {
    public function draw() {
        echo "Drawing a Circle";
    }
}

class Square implements Shape {
    public function draw() {
        echo "Drawing a Square";
    }
}

class ShapeFactory {
    public static function createShape($type) {
        if ($type === 'circle') {
            return new Circle();
        } elseif ($type === 'square') {
            return new Square();
        }
        return null;
    }
}

// Sử dụng Factory
$shape = ShapeFactory::createShape('circle');
$shape->draw();  // Output: Drawing a Circle
```

### 3. **Observer Pattern**

**Mục đích:** Định nghĩa một mối quan hệ phụ thuộc một-nhiều giữa các đối tượng, sao cho khi một đối tượng thay đổi trạng thái, tất cả các đối tượng phụ thuộc của nó đều được thông báo và cập nhật tự động.

**Ví dụ:**

```php
interface Observer {
    public function update($message);
}

class ConcreteObserver implements Observer {
    private $name;

    public function __construct($name) {
        $this->name = $name;
    }

    public function update($message) {
        echo "$this->name received message: $message\n";
    }
}

class Subject {
    private $observers = [];

    public function addObserver(Observer $observer) {
        $this->observers[] = $observer;
    }

    public function notifyObservers($message) {
        foreach ($this->observers as $observer) {
            $observer->update($message);
        }
    }
}

// Sử dụng Observer
$observer1 = new ConcreteObserver('Observer 1');
$observer2 = new ConcreteObserver('Observer 2');

$subject = new Subject();
$subject->addObserver($observer1);
$subject->addObserver($observer2);

$subject->notifyObservers('Hello, Observers!');
// Output:
// Observer 1 received message: Hello, Observers!
// Observer 2 received message: Hello, Observers!
```

### 4. **Strategy Pattern**

**Mục đích:** Định nghĩa một họ các thuật toán, đóng gói từng thuật toán và làm cho chúng có thể thay thế nhau.

**Ví dụ:**

```php
interface PaymentStrategy {
    public function pay($amount);
}

class CreditCardPayment implements PaymentStrategy {
    public function pay($amount) {
        echo "Paying $amount using Credit Card";
    }
}

class PaypalPayment implements PaymentStrategy {
    public function pay($amount) {
        echo "Paying $amount using PayPal";
    }
}

class ShoppingCart {
    private $paymentStrategy;

    public function setPaymentStrategy(PaymentStrategy $strategy) {
        $this->paymentStrategy = $strategy;
    }

    public function checkout($amount) {
        $this->paymentStrategy->pay($amount);
    }
}

// Sử dụng Strategy
$cart = new ShoppingCart();
$cart->setPaymentStrategy(new PaypalPayment());
$cart->checkout(100);  // Output: Paying 100 using PayPal
```

### 5. **Decorator Pattern**

**Mục đích:** Cho phép thêm trách nhiệm vào đối tượng một cách linh hoạt mà không làm thay đổi code của các lớp hiện có.

**Ví dụ:**

```php
interface Coffee {
    public function getCost();
    public function getDescription();
}

class SimpleCoffee implements Coffee {
    public function getCost() {
        return 5;
    }

    public function getDescription() {
        return "Simple coffee";
    }
}

class MilkDecorator implements Coffee {
    protected $coffee;

    public function __construct(Coffee $coffee) {
        $this->coffee = $coffee;
    }

    public function getCost() {
        return $this->coffee->getCost() + 2;
    }

    public function getDescription() {
        return $this->coffee->getDescription() . ", milk";
    }
}

class SugarDecorator implements Coffee {
    protected $coffee;

    public function __construct(Coffee $coffee) {
        $this->coffee = $coffee;
    }

    public function getCost() {
        return $this->coffee->getCost() + 1;
    }

    public function getDescription() {
        return $this->coffee->getDescription() . ", sugar";
    }
}

// Sử dụng Decorator
$coffee = new SimpleCoffee();
$coffee = new MilkDecorator($coffee);
$coffee = new SugarDecorator($coffee);

echo $coffee->getDescription();  // Output: Simple coffee, milk, sugar
echo $coffee->getCost();         // Output: 8
```

### 6. **Adapter Pattern**

**Mục đích:** Cho phép giao tiếp giữa các lớp có giao diện không tương thích bằng cách sử dụng một lớp "adapter" để chuyển đổi giao diện của một lớp thành giao diện mong đợi bởi lớp khác.

**Ví dụ:**

```php
interface MediaPlayer {
    public function play($audioType, $fileName);
}

class Mp3Player implements MediaPlayer {
    public function play($audioType, $fileName) {
        if ($audioType === 'mp3') {
            echo "Playing mp3 file: $fileName";
        } else {
            echo "Invalid media. mp3 format supported.";
        }
    }
}

interface AdvancedMediaPlayer {
    public function playVlc($fileName);
    public function playMp4($fileName);
}

class VlcPlayer implements AdvancedMediaPlayer {
    public function playVlc($fileName) {
        echo "Playing vlc file: $fileName";
    }

    public function playMp4($fileName) {
        // do nothing
    }
}

class Mp4Player implements AdvancedMediaPlayer {
    public function playVlc($fileName) {
        // do nothing
    }

    public function playMp4($fileName) {
        echo "Playing mp4 file: $fileName";
    }
}

class MediaAdapter implements MediaPlayer {
    protected $advancedMusicPlayer;

    public function __construct($audioType) {
        if ($audioType === 'vlc') {
            $this->advancedMusicPlayer = new VlcPlayer();
        } elseif ($audioType === 'mp4') {
            $this->advancedMusicPlayer = new Mp4Player();
        }
    }

    public function play($audioType, $fileName) {
        if ($audioType === 'vlc') {
            $this->advancedMusicPlayer->playVlc($fileName);
        } elseif ($audioType === 'mp4') {
            $this->advancedMusicPlayer->playMp4($fileName);
        }
    }
}

// Sử dụng Adapter
class AudioPlayer implements MediaPlayer {
    protected $mediaAdapter;

    public function play($audioType, $fileName) {
        if ($audioType === 'mp3') {
            echo "Playing mp3 file: $fileName";
        } elseif ($audioType === 'vlc' || $audioType === 'mp4') {
            $this->mediaAdapter = new MediaAdapter($audioType);
            $this->mediaAdapter->play($audioType, $fileName);
        } else {
            echo "Invalid media. $audioType format not supported.";
        }
    }
}

$audioPlayer = new AudioPlayer();
$audioPlayer->play("mp3", "song.mp3");
$audioPlayer->play("mp4", "video.mp4");
$audioPlayer->play("vlc", "movie.vlc");
```

### 7. **Facade Pattern**

**Mục đích:** Cung cấp một giao diện đơn giản để tương tác với một hệ thống phức tạp, ẩn đi chi tiết của các lớp hoặc API phức tạp bên trong.

**Ví dụ:**

```php
class CPU {
    public function freeze() {
        echo "CPU freeze\n";
    }

    public function jump($position) {
        echo "CPU jump to " . $position . "\n";
    }

    public function execute() {
        echo "CPU execute\n";
    }
}

class Memory {
    public function load($position, $data) {
        echo "Loading data at position " . $position . "\n";
    }
}

class HardDrive {
    public function read($lba, $size) {
        echo "Reading data from LBA " . $lba . " with size " . $size . "\n";
    }
}

class ComputerFacade {
    protected $cpu;
    protected $memory;
    protected $hardDrive;

    public function __construct() {
        $this->cpu = new CPU();
        $this->memory = new Memory();
        $this->hardDrive = new HardDrive();
    }

    public function start() {
        $this->cpu->freeze();
        $this->memory->load(0x00, $this->hardDrive->read(0x00, 512));
        $this->cpu->jump(0x00);
        $this->cpu->execute();
    }
}

$computer = new ComputerFacade();
$computer->start();

```
Giải thích: Decorator Pattern cho phép thêm các tính năng mới cho một đối tượng mà không cần thay đổi mã gốc của nó. Điều này giúp mã dễ dàng mở rộng mà không ảnh hưởng đến tính toàn vẹn của lớp ban đầu.
